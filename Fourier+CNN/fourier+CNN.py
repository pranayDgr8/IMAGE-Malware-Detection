# -*- coding: utf-8 -*-
"""ismJcompFourierCNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qBwBk8rEbonI_RjEl9Ogv1pUAAPOzOpg

## **IMAGE MALWARE DETECTION with Fourier+CNN**

Pranaydeep Mayank
19BAI1026
"""

from google.colab import drive
drive.mount('/content/drive')

data='/content/drive/MyDrive/AI for cyber_sec/malimg_paper_dataset_imgs'

data="/content/drive/MyDrive/AI for cyber_sec/malimg_paper_dataset_imgs"

from keras.preprocessing.image import ImageDataGenerator
batches = ImageDataGenerator().flow_from_directory(directory=data, target_size=(64,64), batch_size=10000)

batches.class_indices

imgs, labels = next(batches)

imgs.shape

labels.shape

labels

#imgs12=imgs.reshape
imgs12=tf.reshape()

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(imgs/255.,labels, test_size=0.3)

pic='/content/drive/MyDrive/AI for cyber_sec/malimg_paper_dataset_imgs/Allaple.A/000012cb3104b542b482df95cd31cec2.png'

import cv2
import numpy as np
from matplotlib import pyplot as plt

img1 = cv2.imread(pic,0)
f = np.fft.fft2(img1)
fshift = np.fft.fftshift(f)
magnitude_spectrum = 20*np.log(np.abs(fshift))

plt.subplot(121),plt.imshow(img1, cmap = 'gray')
plt.title('Input Image'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')
plt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])
plt.show()

img1.shape

def fourier(img):
  import cv2
  import numpy as np
  from matplotlib import pyplot as plt
  #img = cv2.imread(pic,0)
  f = np.fft.fft2(img)
  fshift = np.fft.fftshift(f)
  magnitude_spectrum = 20*np.log(np.abs(fshift))
  plt.subplot(121),plt.imshow(img, cmap = 'gray')
  plt.title('Input Image'), plt.xticks([]), plt.yticks([])
  plt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')
  plt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])
  plt.show()

  return magnitude_spectrum

for sample in X_train:
  print(sample.shape)
  #X_transformed.append(fourier(sample))
#X_transformed

X_transformed=[]
for sample in X_train:
  X_transformed.append(fourier(sample))
X_transformed

X_train.shape

import keras
from keras.models import Sequential, Input, Model
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import BatchNormalization

num_classes = 25

y_train.shape

import numpy as np
y_train_new = np.argmax(y_train, axis=1)

y_test_new = np.argmax(y_test, axis=1)

y_train_new

malwares=['Adialer.C',
  'Agent.FYI',
 'Allaple.A',
 'Allaple.L',
 'Alueron.gen!J',
 'Autorun.K',
 'C2LOP.P',
 'C2LOP.gen!g',
 'Dialplatform.B',
 'Dontovo.A',
 'Fakerean',
 'Instantaccess',
 'Lolyda.AA1',
 'Lolyda.AA2',
 'Lolyda.AA3',
 'Lolyda.AT',
 'Malex.gen!J',
 'Obfuscator.AD',
 'Rbot!gen',
 'Skintrim.N',
 'Swizzor.gen!E',
 'Swizzor.gen!I',
 'VB.AT',
 'Wintrim.BX',
 'Yuner.A']

import numpy as np
import scipy as sp
from PIL import Image
import matplotlib.pyplot as plt


def plot_sample(X,y,index):
  plt.figure(figsize=(15,2))
  plt.imshow(X_train[index])
  plt.xlabel(malwares[y_train_new[index]])

#import matplotlib as plt
plot_sample(X_train,y_train_new,1000)

from tensorflow.keras import layers,models

cnn=models.Sequential([
                       #cnn
                       layers.Conv2D(30, kernel_size=(3,3),activation='relu',input_shape=(64,64,3)),
                       layers.MaxPooling2D(pool_size=(2, 2)),
                       layers.Dropout(0.25),
                       
                       
                       #dense
                       layers.Flatten(),
                       layers.Dense(128, activation='relu'),
                       layers.Dropout(0.5),
                       layers.Dense(50,activation='relu'),
                       layers.Dense(num_classes,activation='softmax')

])

cnn.compile(loss='categorical_crossentropy', optimizer = 'adam', metrics=['accuracy'])

y_train

"""X_transformed=[]
for sample in X_train:
  X_transformed.append(fourier(sample))
"""

import tensorflow as tf
tf.reshape(X_transformed,[6538, 64, 64, 3])

X_train1=X_train

for sample in X_train1:
  sample=fourier(sample)
  #X_transformed.append(fourier(sample))

X_train1.shape

import tensorflow as tf


tf.config.run_functions_eagerly(True)
cnn.fit(X_train1,y_train)

cnn.fit(X_train1,y_train,epochs=10)

X_test1=X_test

for sample in X_test1:
  sample=fourier(sample)

y_test

scores = cnn.evaluate(X_test1, y_test)

print('Final Fourier+CNN accuracy: ', scores[1])

import numpy as np
import pandas as pd

predictions = cnn.predict(X_test1)

y_pred = cnn.predict(X_test1, verbose=0)

y_pred[:5]

for x in range (0,5):
  plot_sample(X_test,y_test2,x)

y_classes=[np.argmax(element) for element in y_pred]
y_classes[:5]

y_test2 = np.argmax(y_test, axis=1)

y_test2[:5]

from sklearn import metrics
c_matrix = metrics.confusion_matrix(y_test2, y_pred.argmax(axis=1))

import seaborn as sns
def confusion_matrix(confusion_matrix, class_names, figsize = (10,7), fontsize=14):
   
    df_cm = pd.DataFrame(
        confusion_matrix, index=class_names, columns=class_names, 
    )
    fig = plt.figure(figsize=figsize)
    try:
        heatmap = sns.heatmap(df_cm, annot=True, fmt="d")
    except ValueError:
        raise ValueError("Confusion matrix values must be integers.")
    heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=fontsize)
    heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=45, ha='right', fontsize=fontsize)
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

class_names= batches.class_indices.keys()
confusion_matrix(c_matrix, class_names, figsize = (20,7), fontsize=14)